The BFS algorithm was AI generated, didnt need to be but this was faster:
This was the prompt:
""""
In godot 4.4.1, I have this action class, this action class is to be used on a TileMapLayer2D
and I want to know the possible systems i can put in place to add variety to the range of the action,
my first thought was to just have a 2d boolean array in which indexes of the array match to the tiles
surrounding the origin of the action, this array would be a size of 22 representing 2 squares from the
origin, then the pattern will flow outward to the other tiles by a size of the action, simply repeating
the pattern as action range increases, are there other forms of this?
""""
This is the result Aaron found useful:
""""
func get_bfs_range(start_pos: Vector2i, range: int, tilemap: TileMap) -> Array[Vector2i]:
	var frontier: Array[Vector2i] = [start_pos]
	var visited: Dictionary = {start_pos: 0} # Use a Dictionary to store distance
	var valid_tiles: Array[Vector2i] = [start_pos]

	var head = 0
	while head < frontier.size():
		var current_pos = frontier[head]
		head += 1

		var current_dist = visited[current_pos]
		if current_dist >= range:
			continue

		# Check neighbors (up, down, left, right)
		for direction in [Vector2i.UP, Vector2i.DOWN, Vector2i.LEFT, Vector2i.RIGHT]:
			var neighbor_pos = current_pos + direction
			if not visited.has(neighbor_pos):
				# YOUR LOGIC HERE: Check if the neighbor is a valid, non-blocking tile.
				# For example: if tilemap.get_cell_source_id(0, neighbor_pos) != WALL_TILE:
				visited[neighbor_pos] = current_dist + 1
				frontier.append(neighbor_pos)
				valid_tiles.append(neighbor_pos)

	return valid_tiles
""""
then the pattern scaler function in globals was also AI generated:
prompt:
""""
okay so rename the actionpattern to pattern2d for the class name and create a function
that given the tilemap(tilemap2d), pattern(pattern2d) and distance(int) to return the valid
tiles (tiles that are filled in on the tilemap) that match the patern, expanded via a distance
function
""""
used response segment:
""""
func get_scaled_pattern_tiles(origin: Vector2i, pattern: Pattern2D, distance: int, tilemap: TileMap) -> Array[Vector2i]:
	var valid_tiles: Array[Vector2i] = []
	if not pattern:
		# If no pattern is provided, return an empty array.
		return valid_tiles

	# Ensure distance is at least 1 to prevent the pattern from collapsing to a single point.
	# A distance of 1 will use the pattern as-is.
	var effective_distance = max(1, distance)

	for offset in pattern.affected_tiles:
		# Scale the pattern's offset vector by the given distance.
		var scaled_offset = offset * effective_distance
		var target_pos = origin + scaled_offset

		# Check if the target cell on the tilemap actually exists (is not empty).
		# We assume layer 0 for this example. Change if your map uses other layers.
		if tilemap.get_cell_source_id(0, target_pos) != -1:
			valid_tiles.append(target_pos)

	return valid_tiles
""""



var _current_pattern: Pattern2D = null
# A reference to the main EditorPlugin, which will be set by plugin.gd
var editor_plugin_instance: EditorPlugin = null

# This function tells the editor that this plugin can handle objects of type Pattern2D.
func _can_handle(object) -> bool:
	return object is Pattern2D


# This function hides the original "affected_tiles" property from the inspector,
# since we will be controlling it with our custom UI.
func _parse_property(object, type, name, hint_type, hint_string, usage_flags, wide) -> bool:
	if name == "affected_tiles":
		return true # We handled it, so don't draw the default editor.
	return false # Let the default inspector handle all other properties.


# This function is where we build and add our custom UI controls.
func _parse_begin(object):
	_current_pattern = object as Pattern2D
	if not _current_pattern:
		return

	# Add a descriptive label for our UI section.
	var label = Label.new()
	label.text = "Affected Tiles Grid:"
	add_custom_control(label)

	# Create a GridContainer to hold our checkboxes.
	var grid = GridContainer.new()
	grid.columns = _current_pattern.grid_size.x
	add_custom_control(grid)

	# --- NEW: Calculate the offset to center the grid ---
	var offset = _current_pattern.grid_size / 2
	# ----------------------------------------------------

	# Create a checkbox for each cell in the grid.
	# The raw loops still go from 0 to size-1 for the GridContainer.
	for y_raw in range(_current_pattern.grid_size.y):
		for x_raw in range(_current_pattern.grid_size.x):
			# --- NEW: Calculate the centered position ---
			var pos := Vector2(x_raw - offset.x, y_raw - offset.y)
			# --------------------------------------------
			
			var checkbox = CheckButton.new()
			checkbox.tooltip_text = str(pos)
			
			# Highlight the origin tile (0,0), which is now the center.
			if pos == Vector2.ZERO:
				# Use self_modulate to give the origin a distinct color.
				checkbox.self_modulate = Color(0.7, 0.9, 1.0) # Light Blue
				checkbox.tooltip_text += " (Origin)"
			
			# Set its state based on whether the position is in the array.
			checkbox.button_pressed = _current_pattern.affected_tiles.has(pos)
			
			# Connect the toggled signal to our handler function.
			# We pass the new, centered position vector as a bound argument.
			checkbox.toggled.connect(_on_tile_toggled.bind(pos))
			
			grid.add_child(checkbox)


# This function is called whenever a checkbox in our grid is clicked.
# NO CHANGES ARE NEEDED HERE, as it works with the logical 'pos' vector.
func _on_tile_toggled(is_pressed: bool, pos: Vector2):
	if not _current_pattern or not editor_plugin_instance:
		return

	# Using UndoRedo allows the user to undo/redo their changes in the editor.
	# We get it from our reference to the main EditorPlugin script.
	var undo_redo: UndoRedo = editor_plugin_instance.get_undo_redo()
	var original_tiles = _current_pattern.affected_tiles.duplicate()
	var new_tiles = original_tiles.duplicate()

	# Add or remove the tile position from the new array.
	if is_pressed:
		if not new_tiles.has(pos):
			new_tiles.append(pos)
	else:
		if new_tiles.has(pos):
			new_tiles.erase(pos)

	# Create an undoable action.
	undo_redo.create_action("Toggle Pattern Tile")
	undo_redo.add_do_property(_current_pattern, "affected_tiles", new_tiles)
	undo_redo.add_undo_property(_current_pattern, "affected_tiles", original_tiles)
	undo_redo.commit_action()
